package com.guildofsmiths.trademesh.service

import android.util.Log
import com.guildofsmiths.trademesh.data.CordMessageClass
import com.guildofsmiths.trademesh.data.IdentityResolver
import com.guildofsmiths.trademesh.data.Message
import com.guildofsmiths.trademesh.data.MessageRepository
import com.guildofsmiths.trademesh.data.PeerRepository
import com.guildofsmiths.trademesh.data.SupabaseAuth
import com.guildofsmiths.trademesh.data.UserPreferences
import io.github.jan.supabase.postgrest.from
import io.github.jan.supabase.postgrest.query.Columns
import io.github.jan.supabase.realtime.channel
import io.github.jan.supabase.realtime.postgresChangeFlow
import io.github.jan.supabase.realtime.realtime
import io.github.jan.supabase.realtime.PostgresAction
import io.github.jan.supabase.storage.storage
import io.github.jan.supabase.storage.upload
import android.content.Context
import android.net.Uri
import java.io.InputStream
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.launchIn
import kotlinx.coroutines.flow.onEach
import kotlinx.coroutines.launch
import kotlinx.serialization.Serializable
import java.util.UUID

/**
 * SupabaseChat - Global chat via Supabase Realtime
 * 
 * Provides real-time messaging that works anywhere in the world.
 * Falls back gracefully when offline (messages queue locally).
 * 
 * Features:
 * - Real-time message sync via Supabase Realtime
 * - Presence tracking (who's online)
 * - Offline queue with auto-sync
 * - Seamless integration with BLE mesh
 */
object SupabaseChat {
    
    private const val TAG = "SupabaseChat"
    private const val MESSAGES_TABLE = "messages"
    private const val PRESENCE_TABLE = "presence"
    
    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    
    // Connection state
    private val _isConnected = MutableStateFlow(false)
    val isConnected: StateFlow<Boolean> = _isConnected.asStateFlow()
    
    private val _onlineUsers = MutableStateFlow<List<OnlineUser>>(emptyList())
    val onlineUsers: StateFlow<List<OnlineUser>> = _onlineUsers.asStateFlow()
    
    // Offline queue
    private val offlineQueue = mutableListOf<MessageRow>()
    
    // Realtime channels
    private var messagesChannel: io.github.jan.supabase.realtime.RealtimeChannel? = null
    private var presenceChannel: io.github.jan.supabase.realtime.RealtimeChannel? = null
    private var messagesSubscriptionJob: Job? = null
    private var presenceSubscriptionJob: Job? = null
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DATA CLASSES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    @Serializable
    data class MessageRow(
        val id: String = UUID.randomUUID().toString(),
        val channel_id: String,
        val sender_id: String,
        val sender_name: String,
        val device_id: String? = null,  // PHYSICAL device identifier for identity resolution
        val content: String,
        val timestamp: Long = System.currentTimeMillis(),
        val is_mesh_origin: Boolean = false,
        val created_at: String? = null,  // Auto-generated by Supabase
        val media_type: String? = null,  // "image", "voice", "video", "file"
        val media_url: String? = null,
        val media_filename: String? = null,
        val media_size: Long? = null,
        val media_duration: Int? = null
    )
    
    /**
     * Media attachment for messages
     */
    data class MediaAttachment(
        val type: String,  // "image", "voice", "video", "file"
        val url: String,
        val filename: String? = null,
        val mimeType: String? = null,
        val size: Long? = null,
        val duration: Int? = null  // For voice/video in seconds
    )
    
    @Serializable
    data class OnlineUser(
        val user_id: String,
        val user_name: String,
        val last_seen: Long,
        val status: String = "online"
    )
    
    @Serializable
    data class PresenceRow(
        val user_id: String,
        val user_name: String,
        val last_seen: Long = System.currentTimeMillis(),
        val status: String = "online"
    )
    
    @Serializable
    data class ChannelRow(
        val id: String,
        val name: String,
        val type: String = "group",
        val creator_id: String,
        val created_at: Long = System.currentTimeMillis(),
        val is_archived: Boolean = false,
        val is_deleted: Boolean = false
    )
    
    /**
     * Represents a channel available to join from the dashboard
     */
    data class AvailableChannel(
        val id: String,
        val name: String,
        val type: String,
        val creatorId: String,
        val createdAt: Long
    )
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONNECTION
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /** Mutex to prevent concurrent channel setup */
    private val channelSetupMutex = kotlinx.coroutines.sync.Mutex()
    
    /** Flag to track if channels are already set up */
    private var channelsSetUp = false
    
    /**
     * Connect to Supabase Realtime for chat
     */
    @Synchronized
    fun connect() {
        val client = SupabaseAuth.client
        if (client == null) {
            Log.w(TAG, "Supabase client not initialized")
            return
        }
        
        // Quick check - if already connected AND channels set up, skip entirely
        if (_isConnected.value && channelsSetUp) {
            Log.d(TAG, "Already connected and channels set up - skipping")
            return
        }
        
        Log.i(TAG, "Connecting to Supabase Realtime...")
        
        scope.launch {
            // Use mutex to prevent concurrent channel setup
            if (!channelSetupMutex.tryLock()) {
                Log.d(TAG, "Channel setup already in progress - skipping")
                return@launch
            }
            
            try {
                // Double-check after acquiring lock
                if (_isConnected.value && channelsSetUp) {
                    Log.d(TAG, "Already connected (after lock) - skipping")
                    return@launch
                }
                
                // Check if realtime is already connected to avoid crash
                val realtimeStatus = client.realtime.status.value
                Log.d(TAG, "Current realtime status: $realtimeStatus")
                
                if (realtimeStatus == io.github.jan.supabase.realtime.Realtime.Status.CONNECTED) {
                    Log.d(TAG, "Realtime already connected, setting up channels once")
                    _isConnected.value = true
                    if (!channelsSetUp) {
                        setupChannelsIfNeeded(client)
                        channelsSetUp = true
                    }
                    return@launch
                }
                
                // Only connect if not already connected or connecting
                if (realtimeStatus != io.github.jan.supabase.realtime.Realtime.Status.CONNECTING) {
                    setupChannelsIfNeeded(client)
                    channelsSetUp = true
                } else {
                    Log.d(TAG, "Realtime is currently connecting, waiting...")
                    // Wait for connection to complete
                    kotlinx.coroutines.delay(1000)
                    if (client.realtime.status.value == io.github.jan.supabase.realtime.Realtime.Status.CONNECTED) {
                        _isConnected.value = true
                        if (!channelsSetUp) {
                            setupChannelsIfNeeded(client)
                            channelsSetUp = true
                        }
                    }
                }
                
            } catch (e: IllegalStateException) {
                // Websocket already connected - this is fine, just mark as connected
                Log.w(TAG, "Websocket already connected (caught exception), marking as connected")
                _isConnected.value = true
            } catch (e: Exception) {
                Log.e(TAG, "Failed to connect to Supabase Realtime", e)
                _isConnected.value = false
            } finally {
                channelSetupMutex.unlock()
            }
        }
    }
    
    /**
     * Set up realtime channels - always recreate to ensure fresh subscriptions
     */
    private suspend fun setupChannelsIfNeeded(client: io.github.jan.supabase.SupabaseClient) {
        try {
            Log.i(TAG, "Setting up realtime channels...")
            
            // Clean up existing channels first
            try {
                messagesSubscriptionJob?.cancel()
                presenceSubscriptionJob?.cancel()
                messagesChannel?.unsubscribe()
                presenceChannel?.unsubscribe()
            } catch (e: Exception) {
                Log.w(TAG, "Error cleaning up old channels: ${e.message}")
            }
            messagesChannel = null
            presenceChannel = null
            
            // Create messages channel
            Log.i(TAG, "Creating messages channel...")
            messagesChannel = client.realtime.channel("messages-realtime")
                
                // Subscribe to new messages (real-time)
                messagesSubscriptionJob = messagesChannel!!
                    .postgresChangeFlow<PostgresAction.Insert>(schema = "public") {
                        table = MESSAGES_TABLE
                    }
                    .onEach { change ->
                        Log.i(TAG, "ğŸ“¨ POSTGRES INSERT EVENT RECEIVED!")
                        handleNewMessage(change.record)
                    }
                    .launchIn(scope)
                
            // Subscribe to messages channel AFTER setting up the flow
                messagesChannel!!.subscribe()
            Log.i(TAG, "âœ… Messages channel subscribed to table: $MESSAGES_TABLE")
                
            // Create presence channel
            Log.d(TAG, "Creating presence channel...")
            presenceChannel = client.realtime.channel("presence-realtime")
                
                // Subscribe to presence changes (real-time - no polling!)
                presenceSubscriptionJob = presenceChannel!!
                    .postgresChangeFlow<PostgresAction>(schema = "public") {
                        table = PRESENCE_TABLE
                    }
                    .onEach { change ->
                        when (change) {
                            is PostgresAction.Insert -> handlePresenceUpdate(change.record)
                            is PostgresAction.Update -> handlePresenceUpdate(change.record)
                            is PostgresAction.Delete -> handlePresenceDelete(change.oldRecord)
                            else -> {}
                        }
                    }
                    .launchIn(scope)
                
                // Subscribe to presence channel
                presenceChannel!!.subscribe()
            Log.i(TAG, "âœ… Presence channel subscribed to table: $PRESENCE_TABLE")
                
                _isConnected.value = true
                Log.i(TAG, "âœ“ Connected to Supabase Realtime (messages + presence)")
                
                // Update our presence immediately
                updatePresence()
                
                // Sync any queued messages
                syncOfflineQueue()
                
                // Load recent messages
                loadRecentMessages()
                
                // Load current online users
                loadOnlineUsers()
                
            } catch (e: Exception) {
            Log.e(TAG, "Failed to setup channels", e)
        }
    }
    
    /**
     * Disconnect from Supabase Realtime
     */
    fun disconnect() {
        Log.i(TAG, "Disconnecting from Supabase Realtime")
        
        // Reset channel setup flag so reconnect will set up channels again
        channelsSetUp = false
        
        scope.launch {
            try {
                // Cancel all subscriptions
                messagesSubscriptionJob?.cancel()
                presenceSubscriptionJob?.cancel()
                
                // Unsubscribe from channels
                messagesChannel?.unsubscribe()
                presenceChannel?.unsubscribe()
                
                messagesChannel = null
                presenceChannel = null
                _isConnected.value = false
            } catch (e: Exception) {
                Log.e(TAG, "Error disconnecting", e)
            }
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MESSAGING
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * Send a message via Supabase
     * If offline, queues for later sync
     */
    fun sendMessage(message: Message, media: MediaAttachment? = null) {
        // #region agent log
        Log.w("DEBUG_MSG", "SUPABASE sendMessage: msgId=${message.id.take(8)} channelId=${message.channelId} beaconId=${message.beaconId} content='${message.content.take(20)}' isConnected=${_isConnected.value}")
        // #endregion
        Log.i(TAG, "ğŸ“¤ sendMessage called: ${message.content.take(30)}")
        Log.d(TAG, "   isConnected: ${_isConnected.value}")
        
        val row = MessageRow(
            id = message.id,
            channel_id = message.channelId,
            sender_id = message.senderId,
            sender_name = message.senderName,
            device_id = message.deviceId ?: UserPreferences.getDeviceId(), // Include physical device ID
            content = message.content,
            timestamp = message.timestamp,
            is_mesh_origin = message.isMeshOrigin,
            media_type = media?.type,
            media_url = media?.url,
            media_filename = media?.filename,
            media_size = media?.size,
            media_duration = media?.duration
        )
        
        // Check actual Supabase connection status
        val client = SupabaseAuth.client
        val isActuallyConnected = client != null && 
            (client.realtime.status.value == io.github.jan.supabase.realtime.Realtime.Status.CONNECTED || _isConnected.value)
        
        Log.d(TAG, "   actuallyConnected: $isActuallyConnected")
        
        if (isActuallyConnected) {
            // Send immediately
            scope.launch {
                try {
                    insertMessage(row)
                    Log.i(TAG, "âœ“ Message sent to Supabase: ${message.content.take(30)} ${if (media != null) "[${media.type}]" else ""}")
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to send message to Supabase, queuing", e)
                    queueMessage(row)
                }
            }
        } else {
            // Queue for later
            Log.w(TAG, "â¸ï¸ Not connected, queuing message: ${message.content.take(30)}")
            queueMessage(row)
        }
    }
    
    /**
     * Upload a file to Supabase Storage and send as message
     */
    suspend fun uploadAndSendMedia(
        context: Context,
        channelId: String,
        uri: Uri,
        caption: String = ""
    ): Result<MediaAttachment> {
        val client = SupabaseAuth.client ?: return Result.failure(Exception("Not connected"))
        
        return try {
            // Get file info
            val contentResolver = context.contentResolver
            val mimeType = contentResolver.getType(uri) ?: "application/octet-stream"
            val fileName = getFileNameFromUri(context, uri) ?: "file_${System.currentTimeMillis()}"
            val fileSize = getFileSizeFromUri(context, uri)
            
            Log.i(TAG, "ğŸ“¤ Uploading file: $fileName ($mimeType, ${fileSize / 1024}KB)")
            
            // Read file bytes
            val inputStream: InputStream = contentResolver.openInputStream(uri)
                ?: return Result.failure(Exception("Cannot read file"))
            val bytes = inputStream.readBytes()
            inputStream.close()
            
            // Generate storage path
            val fileExt = fileName.substringAfterLast('.', "bin")
            val storagePath = "$channelId/${System.currentTimeMillis()}-${UUID.randomUUID()}.$fileExt"
            
            // Upload to Supabase Storage
            val bucket = client.storage.from("media")
            bucket.upload(storagePath, bytes, upsert = false)
            
            // Get public URL
            val publicUrl = bucket.publicUrl(storagePath)
            
            Log.i(TAG, "âœ“ File uploaded: $publicUrl")
            
            // Determine media type
            val mediaType = when {
                mimeType.startsWith("image/") -> "image"
                mimeType.startsWith("audio/") -> "voice"
                mimeType.startsWith("video/") -> "video"
                else -> "file"
            }
            
            val media = MediaAttachment(
                type = mediaType,
                url = publicUrl,
                filename = fileName,
                mimeType = mimeType,
                size = fileSize
            )
            
            // Send message with media
            val message = Message(
                id = UUID.randomUUID().toString(),
                channelId = channelId,
                senderId = UserPreferences.getUserId(),
                senderName = UserPreferences.getUserName() ?: "Unknown",
                content = caption.ifBlank { "ğŸ“ $fileName" },
                timestamp = System.currentTimeMillis(),
                isMeshOrigin = false
            )
            
            sendMessage(message, media)
            
            // Also add to local repository
            MessageRepository.addMessage(message)
            
            Result.success(media)
            
        } catch (e: Exception) {
            Log.e(TAG, "Upload failed", e)
            Result.failure(e)
        }
    }
    
    /**
     * Get filename from Uri
     */
    private fun getFileNameFromUri(context: Context, uri: Uri): String? {
        return context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
            val nameIndex = cursor.getColumnIndex(android.provider.OpenableColumns.DISPLAY_NAME)
            cursor.moveToFirst()
            if (nameIndex >= 0) cursor.getString(nameIndex) else null
        }
    }
    
    /**
     * Get file size from Uri
     */
    private fun getFileSizeFromUri(context: Context, uri: Uri): Long {
        return context.contentResolver.query(uri, null, null, null, null)?.use { cursor ->
            val sizeIndex = cursor.getColumnIndex(android.provider.OpenableColumns.SIZE)
            cursor.moveToFirst()
            if (sizeIndex >= 0) cursor.getLong(sizeIndex) else 0L
        } ?: 0L
    }
    
    /**
     * Insert message into Supabase
     */
    private suspend fun insertMessage(row: MessageRow) {
        val client = SupabaseAuth.client ?: return
        
        client.from(MESSAGES_TABLE).insert(row)
    }
    
    /**
     * Queue message for offline sync
     */
    private fun queueMessage(row: MessageRow) {
        synchronized(offlineQueue) {
            offlineQueue.add(row)
        }
        Log.d(TAG, "Message queued for sync (${offlineQueue.size} pending)")
    }
    
    /**
     * Sync offline queue when connection restored
     */
    private suspend fun syncOfflineQueue() {
        val toSync: List<MessageRow>
        synchronized(offlineQueue) {
            toSync = offlineQueue.toList()
            offlineQueue.clear()
        }
        
        if (toSync.isEmpty()) return
        
        Log.i(TAG, "Syncing ${toSync.size} queued messages...")
        
        toSync.forEach { row ->
            try {
                insertMessage(row)
            } catch (e: Exception) {
                Log.e(TAG, "Failed to sync message ${row.id}", e)
                // Re-queue failed messages
                queueMessage(row)
            }
        }
    }
    
    /**
     * Handle incoming message from Supabase Realtime
     */
    private fun handleNewMessage(record: Map<String, Any?>) {
        try {
            val senderId = record["sender_id"] as? String ?: return
            val myUserId = UserPreferences.getUserId()
            val msgId = record["id"] as? String ?: "unknown"
            val content = (record["content"] as? String ?: "").take(20)
            
            val channelId = record["channel_id"] as? String ?: "unknown"
            // #region agent log
            Log.w("DEBUG_MSG", "REALTIME RECEIVED: msgId=${msgId.take(8)} channelId=$channelId senderId=${senderId.take(8)} myUserId=${myUserId.take(8)} isOwnMsg=${senderId == myUserId} content='$content'")
            // #endregion
            
            // Skip our own messages (we already have them locally)
            if (senderId == myUserId) {
                // #region agent log
                Log.w("DEBUG_MSG", "SKIPPING own message: msgId=${msgId.take(8)}")
                // #endregion
                return
            }
            
            // Parse media attachment if present
            val mediaType = record["media_type"] as? String
            val mediaUrl = record["media_url"] as? String
            val mediaFilename = record["media_filename"] as? String
            val mediaSize = (record["media_size"] as? Number)?.toLong() ?: 0L
            val mediaDuration = (record["media_duration"] as? Number)?.toLong() ?: 0L
            
            val media: com.guildofsmiths.trademesh.data.MediaAttachment? = if (mediaType != null && mediaUrl != null) {
                val type = when (mediaType) {
                    "image" -> com.guildofsmiths.trademesh.data.MediaType.IMAGE
                    "voice" -> com.guildofsmiths.trademesh.data.MediaType.VOICE
                    "video" -> com.guildofsmiths.trademesh.data.MediaType.VIDEO
                    "file" -> com.guildofsmiths.trademesh.data.MediaType.FILE
                    else -> com.guildofsmiths.trademesh.data.MediaType.FILE
                }
                com.guildofsmiths.trademesh.data.MediaAttachment(
                    type = type,
                    remotePath = mediaUrl,
                    fileName = mediaFilename,
                    fileSize = mediaSize,
                    duration = mediaDuration
                )
            } else null
            
            val msgMediaType = when (mediaType) {
                "image" -> com.guildofsmiths.trademesh.data.MediaType.IMAGE
                "voice" -> com.guildofsmiths.trademesh.data.MediaType.VOICE
                "video" -> com.guildofsmiths.trademesh.data.MediaType.VIDEO
                "file" -> com.guildofsmiths.trademesh.data.MediaType.FILE
                else -> com.guildofsmiths.trademesh.data.MediaType.TEXT
            }
            
            val message = Message(
                id = record["id"] as? String ?: UUID.randomUUID().toString(),
                beaconId = "default",  // Ensure beaconId matches for filtering
                channelId = record["channel_id"] as? String ?: "general",
                senderId = senderId,  // Will be resolved by IdentityResolver
                senderName = record["sender_name"] as? String ?: "Unknown",
                deviceId = record["device_id"] as? String,  // Online messages may include device_id
                content = record["content"] as? String ?: "",
                timestamp = (record["timestamp"] as? Number)?.toLong() ?: System.currentTimeMillis(),
                isMeshOrigin = record["is_mesh_origin"] as? Boolean ?: false,
                mediaType = msgMediaType,
                media = media
            )

            // IDENTITY RESOLUTION: Resolve logical author ID from physical device ID
            val resolvedMessage = message.copy(
                senderId = IdentityResolver.resolveAuthorId(
                    deviceId = message.deviceId,
                    knownAuthorId = message.senderId
                )
            )
            
            Log.i(TAG, "ğŸ“¨ REALTIME MESSAGE RECEIVED:")
            Log.i(TAG, "   From: ${resolvedMessage.senderName} (${resolvedMessage.senderId.take(8)})")
            Log.i(TAG, "   Content: ${resolvedMessage.content.take(50)}")
            Log.i(TAG, "   Channel: ${resolvedMessage.channelId}, Beacon: ${resolvedMessage.beaconId}")
            Log.i(TAG, "   Identity resolved: ${message.senderId.take(8)} â†’ ${resolvedMessage.senderId.take(8)}")
            Log.i(TAG, "   Adding to MessageRepository...")

            // Add to local repository
            MessageRepository.addMessage(resolvedMessage)
            Log.i(TAG, "   âœ… Added to repository, total messages: ${MessageRepository.allMessages.value.size}")

            // RECONCILE WITH CORD: Supabase is a propagation node, not authority
            // If this message requires cord protection, reconcile it into our cord
            reconcileSupabaseMessageIntoCord(resolvedMessage)

            // Update peer presence
            PeerRepository.onPeerSeen(resolvedMessage.senderId, resolvedMessage.senderName, 0)
            
        } catch (e: Exception) {
            Log.e(TAG, "Error handling message", e)
        }
    }

    /**
     * Reconcile Supabase message into cord (propagation node â†’ authority).
     * Supabase is a propagation replica, cord is the source of truth.
     */
    private fun reconcileSupabaseMessageIntoCord(message: Message) {
        // Only reconcile messages that require cord protection
        val cordClass = detectCordMessageClass(message)
        if (cordClass == null) return // Regular chat, no cord needed

        kotlinx.coroutines.GlobalScope.launch(Dispatchers.IO) {
            try {
                val cordRepository = com.guildofsmiths.trademesh.data.CordRepository(android.content.ContextWrapper(null).applicationContext)

                // Serialize message for cord storage
                val payload = serializeMessageForCord(message)

                // HARD DEDUPLICATION: appendCordEntry checks semantic MessageID and updates delivery marker
                val cordEntry = cordRepository.appendCordEntry(
                    cordId = message.beaconId,
                    hubId = message.beaconId,
                    channelId = message.channelId,
                    authorId = message.senderId,
                    authorName = message.senderName,
                    messageClass = cordClass,
                    payload = payload,
                    payloadType = "message",
                    threadId = null,
                    deliveryMarker = "Â· online" // Supabase propagation
                )

                if (cordEntry != null) {
                    Log.i(TAG, "ğŸ“ Cord entry created/reconciled from Supabase: ${cordEntry.messageId.take(8)}")
                } else {
                    Log.d(TAG, "ğŸ”„ Cord entry already exists (deduplicated): semantic content from Supabase")
                }
            } catch (e: Exception) {
                Log.e(TAG, "Failed to reconcile Supabase message into cord", e)
            }
        }
    }

    /**
     * Detect if message needs cord protection (same logic as BoundaryEngine).
     */
    private fun detectCordMessageClass(message: Message): CordMessageClass? {
        val content = message.content.lowercase()

        // WORK_LOG: Time entries, labor records
        if (content.contains("clock") || content.contains("time") ||
            content.contains("worked") || content.contains("hours") ||
            message.aiContext?.contains("time_entry") == true) {
            return CordMessageClass.WORK_LOG
        }

        // DECISION: Approvals, rejections, status changes
        if (content.contains("approve") || content.contains("reject") ||
            content.contains("decision") || content.contains("status") ||
            message.aiContext?.contains("decision") == true) {
            return CordMessageClass.DECISION
        }

        // COMMAND: Executable commands, job assignments
        if (content.startsWith("/") || content.contains("assign") ||
            content.contains("command") ||
            message.aiContext?.contains("command") == true) {
            return CordMessageClass.COMMAND
        }

        // ALERT: Warnings, notifications, safety alerts
        if (content.contains("alert") || content.contains("warning") ||
            content.contains("safety") || content.contains("urgent") ||
            message.aiContext?.contains("alert") == true) {
            return CordMessageClass.ALERT
        }

        // AI_SUMMARY: AI-generated summaries and reports
        if (message.aiGenerated && message.aiSource == "llm") {
            return CordMessageClass.AI_SUMMARY
        }

        // STATUS: System status updates
        if (content.contains("status") || content.contains("update") ||
            message.aiContext?.contains("status") == true) {
            return CordMessageClass.STATUS
        }

        // Regular chat doesn't need cord protection
        return null
    }

    /**
     * Create cord entry from message (for reconciliation).
     */
    private fun createCordEntryFromMessage(
        message: Message,
        cordClass: CordMessageClass,
        deliveryMarker: String? = null
    ): com.guildofsmiths.trademesh.data.CordEntry {
        // Serialize message for cord storage
        val payload = org.json.JSONObject(mapOf(
            "originalMessageId" to message.id,
            "content" to message.content,
            "timestamp" to message.timestamp,
            "aiGenerated" to message.aiGenerated,
            "aiModel" to message.aiModel,
            "aiSource" to message.aiSource,
            "aiContext" to message.aiContext,
            "hasMedia" to message.hasMedia(),
            "mediaType" to message.mediaType.name
        )).toString()

        return com.guildofsmiths.trademesh.data.CordEntry(
            messageId = "temp-${System.currentTimeMillis()}", // Will be replaced by cord repository
            cordId = message.beaconId,
            hubId = message.beaconId,
            channelId = message.channelId,
            authorId = message.senderId,
            authorName = message.senderName,
            messageClass = cordClass,
            payload = payload,
            payloadType = "message",
            lamportTimestamp = 0L, // Will be set by cord repository
            authorCounter = 0,
            wallClockTime = message.timestamp,
            signature = "", // Will be set by cord repository
            deliveryMarker = deliveryMarker ?: "Â· local"
        )
    }

    /**
     * Serialize message for cord storage.
     */
    private fun serializeMessageForCord(message: Message): String {
        // Create a JSON representation of the message for cord storage
        // For semantic deduplication, exclude transport-specific fields
        val cordPayload = mutableMapOf<String, Any?>(
            "content" to message.content,
            "aiGenerated" to message.aiGenerated,
            "aiModel" to message.aiModel,
            "aiSource" to message.aiSource,
            "aiContext" to message.aiContext,
            "hasMedia" to message.hasMedia(),
            "recipientId" to message.recipientId,
            "isArchived" to message.isArchived
        )

        // Include media-specific fields for semantic content (not transport-specific)
        if (message.hasMedia() && message.media != null) {
            cordPayload["mediaType"] = message.mediaType.name
            cordPayload["mediaFilename"] = message.media?.fileName
            cordPayload["mediaSize"] = message.media?.fileSize
            // Note: We don't include URLs or upload timestamps as they're transport-specific
        }

        return org.json.JSONObject(cordPayload).toString()
    }

    /**
     * Load recent messages from Supabase
     */
    private suspend fun loadRecentMessages() {
        val client = SupabaseAuth.client ?: return
        
        try {
            val messages = client.from(MESSAGES_TABLE)
                .select()
                .decodeList<MessageRow>()
            
            Log.i(TAG, "Loaded ${messages.size} messages from Supabase")
            
            // Add to local repository (avoiding duplicates)
            messages.forEach { row ->
                // Parse media attachment if present
                val media: com.guildofsmiths.trademesh.data.MediaAttachment? = if (row.media_type != null && row.media_url != null) {
                    val type = when (row.media_type) {
                        "image" -> com.guildofsmiths.trademesh.data.MediaType.IMAGE
                        "voice" -> com.guildofsmiths.trademesh.data.MediaType.VOICE
                        "video" -> com.guildofsmiths.trademesh.data.MediaType.VIDEO
                        "file" -> com.guildofsmiths.trademesh.data.MediaType.FILE
                        else -> com.guildofsmiths.trademesh.data.MediaType.FILE
                    }
                    com.guildofsmiths.trademesh.data.MediaAttachment(
                        type = type,
                        remotePath = row.media_url,
                        fileName = row.media_filename,
                        fileSize = row.media_size ?: 0L,
                        duration = row.media_duration?.toLong() ?: 0L
                    )
                } else null
                
                val msgMediaType = when (row.media_type) {
                    "image" -> com.guildofsmiths.trademesh.data.MediaType.IMAGE
                    "voice" -> com.guildofsmiths.trademesh.data.MediaType.VOICE
                    "video" -> com.guildofsmiths.trademesh.data.MediaType.VIDEO
                    "file" -> com.guildofsmiths.trademesh.data.MediaType.FILE
                    else -> com.guildofsmiths.trademesh.data.MediaType.TEXT
                }
                
                val message = Message(
                    id = row.id,
                    channelId = row.channel_id,
                    senderId = row.sender_id,
                    senderName = row.sender_name,
                    content = row.content,
                    timestamp = row.timestamp,
                    isMeshOrigin = row.is_mesh_origin,
                    mediaType = msgMediaType,
                    media = media
                )
                
                if (media != null) {
                    Log.d(TAG, "ğŸ“ Loaded message with media: ${row.media_type} url=${row.media_url?.take(50)}... channelId=${row.channel_id} mediaType=$msgMediaType")
                }
                
                Log.d(TAG, "ğŸ“ Message: id=${message.id.take(8)} channel=${message.channelId} beacon=${message.beaconId} hasMedia=${message.hasMedia()} mediaType=${message.mediaType} media=${message.media != null}")
                
                MessageRepository.addMessage(message)
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load messages", e)
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PRESENCE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * Update our presence in Supabase
     */
    private suspend fun updatePresence() {
        val client = SupabaseAuth.client ?: return
        val userId = UserPreferences.getUserId()
        val userName = UserPreferences.getUserName() ?: return
        
        try {
            val presence = PresenceRow(
                user_id = userId,
                user_name = userName,
                last_seen = System.currentTimeMillis(),
                status = "online"
            )
            
            // Upsert presence
            client.from(PRESENCE_TABLE).upsert(presence)
            
            Log.d(TAG, "âœ“ Presence updated")
        } catch (e: Exception) {
            Log.w(TAG, "Failed to update presence", e)
        }
    }
    
    /**
     * Load online users from Supabase
     */
    private suspend fun loadOnlineUsers() {
        val client = SupabaseAuth.client ?: return
        val myUserId = UserPreferences.getUserId()
        
        try {
            val users = client.from(PRESENCE_TABLE)
                .select()
                .decodeList<PresenceRow>()
            
            // Filter to recent users (last 2 minutes) - only for initial load
            val recentThreshold = System.currentTimeMillis() - 120_000
            val onlineUsers = users
                .filter { it.last_seen > recentThreshold && it.user_id != myUserId }
                .map { OnlineUser(it.user_id, it.user_name, it.last_seen, it.status) }
            
            _onlineUsers.value = onlineUsers
            
            // Also add to PeerRepository
            onlineUsers.forEach { user ->
                PeerRepository.onPeerSeen(user.user_id, user.user_name, 0)
            }
            
            Log.d(TAG, "Found ${onlineUsers.size} online users")
            
        } catch (e: Exception) {
            Log.w(TAG, "Failed to load online users", e)
        }
    }
    
    /**
     * Handle real-time presence update (instant - no polling!)
     */
    private fun handlePresenceUpdate(record: Map<String, Any?>) {
        try {
            val userId = record["user_id"] as? String ?: return
            val myUserId = UserPreferences.getUserId()
            
            // Skip our own presence
            if (userId == myUserId) return
            
            val userName = record["user_name"] as? String ?: "Unknown"
            val lastSeen = (record["last_seen"] as? Number)?.toLong() ?: System.currentTimeMillis()
            val status = record["status"] as? String ?: "online"
            
            Log.d(TAG, "ğŸ‘¤ Presence update: $userName is $status")
            
            // Update online users list
            val currentList = _onlineUsers.value.toMutableList()
            val existingIndex = currentList.indexOfFirst { it.user_id == userId }
            
            if (status == "online") {
                val user = OnlineUser(userId, userName, lastSeen, status)
                if (existingIndex >= 0) {
                    currentList[existingIndex] = user
                } else {
                    currentList.add(user)
                }
                // Add to PeerRepository
                PeerRepository.onPeerSeen(userId, userName, 0)
            } else {
                // User went offline
                if (existingIndex >= 0) {
                    currentList.removeAt(existingIndex)
                }
            }
            
            _onlineUsers.value = currentList
            
        } catch (e: Exception) {
            Log.e(TAG, "Error handling presence update", e)
        }
    }
    
    /**
     * Handle presence deletion (user went offline)
     */
    private fun handlePresenceDelete(record: Map<String, Any?>) {
        try {
            val userId = record["user_id"] as? String ?: return
            
            Log.d(TAG, "ğŸ‘¤ User offline: $userId")
            
            // Remove from online users list
            val currentList = _onlineUsers.value.toMutableList()
            currentList.removeAll { it.user_id == userId }
            _onlineUsers.value = currentList
            
        } catch (e: Exception) {
            Log.e(TAG, "Error handling presence delete", e)
        }
    }
    
    /**
     * Refresh online users (manual refresh)
     */
    fun refreshOnlineUsers() {
        scope.launch {
            updatePresence()
            loadOnlineUsers()
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CHANNEL DISCOVERY (Dashboard channels)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /** Available channels from dashboard */
    private val _availableChannels = MutableStateFlow<List<AvailableChannel>>(emptyList())
    val availableChannels: StateFlow<List<AvailableChannel>> = _availableChannels.asStateFlow()
    
    /** Channels the user has joined */
    private val _joinedChannelIds = MutableStateFlow<Set<String>>(setOf("general"))
    val joinedChannelIds: StateFlow<Set<String>> = _joinedChannelIds.asStateFlow()
    
    /**
     * Create a new channel in Supabase (globally available)
     * This is the primary way to create channels that sync worldwide.
     */
    suspend fun createChannel(
        name: String,
        type: String,
        creatorId: String,
        callback: (AvailableChannel?, Exception?) -> Unit
    ) {
        val client = SupabaseAuth.client
        if (client == null) {
            callback(null, Exception("Supabase not connected"))
            return
        }
        
        try {
            val channelId = UUID.randomUUID().toString()
            val channelRow = ChannelRow(
                id = channelId,
                name = name,
                type = type,
                creator_id = creatorId,
                created_at = System.currentTimeMillis(),
                is_archived = false,
                is_deleted = false
            )
            
            // Insert into Supabase
            client.from("channels").insert(channelRow)
            
            Log.i(TAG, "âœ… Channel created in Supabase: #$name ($channelId)")
            
            val available = AvailableChannel(
                id = channelId,
                name = name,
                type = type,
                creatorId = creatorId,
                createdAt = channelRow.created_at
            )
            
            // Update local state
            _availableChannels.value = _availableChannels.value + available
            
            callback(available, null)
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to create channel in Supabase", e)
            callback(null, e)
        }
    }
    
    /**
     * Fetch available channels from Supabase (created by dashboard)
     * Also adds them to the local BeaconRepository so they appear in the channel list
     */
    suspend fun fetchAvailableChannels(): List<AvailableChannel> {
        val client = SupabaseAuth.client ?: return emptyList()

        try {
            val channels = client.from("channels")
                .select()
                .decodeList<ChannelRow>()

            val available = channels
                .filter { !it.is_deleted && !it.is_archived }
                .map { row ->
                    AvailableChannel(
                        id = row.id,
                        name = row.name,
                        type = row.type,
                        creatorId = row.creator_id,
                        createdAt = row.created_at
                    )
                }

            _availableChannels.value = available
            Log.i(TAG, "ğŸ“‹ Found ${available.size} available channels from Supabase")

            // Add channels to local BeaconRepository so they appear in the channel list
            available.forEach { ch ->
                Log.d(TAG, "   - #${ch.name} (${ch.id})")

                // Check if channel already exists locally
                if (com.guildofsmiths.trademesh.data.BeaconRepository.getChannel("default", ch.id) == null) {
                    // Add to local repository
                    val localChannel = com.guildofsmiths.trademesh.data.Channel(
                        id = ch.id,
                        beaconId = "default",
                        name = ch.name,
                        type = when (ch.type) {
                            "broadcast" -> com.guildofsmiths.trademesh.data.ChannelType.BROADCAST
                            "group" -> com.guildofsmiths.trademesh.data.ChannelType.GROUP
                            "dm" -> com.guildofsmiths.trademesh.data.ChannelType.DM
                            else -> com.guildofsmiths.trademesh.data.ChannelType.GROUP
                        }
                    )

                    com.guildofsmiths.trademesh.data.BeaconRepository.addChannel("default", localChannel)
                    Log.i(TAG, "   âœ… Added Supabase channel locally: #${ch.name}")

                    // Also join the channel for message routing
                    com.guildofsmiths.trademesh.engine.BoundaryEngine.joinChannel(ch.id)
                }
            }

            return available

        } catch (e: Exception) {
            Log.e(TAG, "Failed to fetch channels", e)
            return emptyList()
        }
    }
    
    /**
     * Join a channel (start receiving messages from it)
     */
    fun joinChannel(channelId: String) {
        _joinedChannelIds.value = _joinedChannelIds.value + channelId
        Log.i(TAG, "âœ… Joined channel: $channelId")
        
        // Also join in BoundaryEngine for mesh routing
        com.guildofsmiths.trademesh.engine.BoundaryEngine.joinChannel(channelId)
    }
    
    /**
     * Leave a channel
     */
    fun leaveChannel(channelId: String) {
        if (channelId == "general") {
            Log.w(TAG, "Cannot leave general channel")
            return
        }
        _joinedChannelIds.value = _joinedChannelIds.value - channelId
        Log.i(TAG, "ğŸ‘‹ Left channel: $channelId")
    }
    
    /**
     * Check if user has joined a channel
     */
    fun isJoined(channelId: String): Boolean {
        return _joinedChannelIds.value.contains(channelId)
    }
    
    /**
     * Get messages for a specific channel
     */
    suspend fun getChannelMessages(channelId: String, limit: Int = 100): List<Message> {
        val client = SupabaseAuth.client ?: return emptyList()
        
        try {
            val messages = client.from(MESSAGES_TABLE)
                .select() {
                    filter {
                        eq("channel_id", channelId)
                    }
                    order("timestamp", io.github.jan.supabase.postgrest.query.Order.ASCENDING)
                    limit(limit.toLong())
                }
                .decodeList<MessageRow>()
            
            Log.d(TAG, "Loaded ${messages.size} messages for channel $channelId")
            
            return messages.map { row ->
                Message(
                    id = row.id,
                    channelId = row.channel_id,
                    senderId = row.sender_id,
                    senderName = row.sender_name,
                    content = row.content,
                    timestamp = row.timestamp,
                    isMeshOrigin = row.is_mesh_origin
                )
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load channel messages", e)
            return emptyList()
        }
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // UTILITIES
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    /**
     * Get pending offline message count
     */
    fun getPendingCount(): Int = synchronized(offlineQueue) { offlineQueue.size }
    
    /**
     * Check if we're connected to Supabase
     */
    fun isOnline(): Boolean = _isConnected.value
}

