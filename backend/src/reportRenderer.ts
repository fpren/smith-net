/**
 * REPORT RENDERER
 * ===============
 *
 * Responsibility: Render report model, apply visual/layout template, format tables/summaries/totals
 * Tech: Template engine, layout rules
 * Output: Human-readable report (PDF / HTML / XLS)
 */

import {
  ReportRenderer as IReportRenderer,
  StructuredReportModel,
  RenderedReport,
  ReportSection
} from './types';
import { v4 as uuidv4 } from 'uuid';

export class ReportRenderer implements IReportRenderer {

  /**
   * RENDER REPORT MODEL
   * Convert structured model to human-readable format
   */
  render(model: StructuredReportModel, format: 'pdf' | 'html' | 'xlsx'): RenderedReport {
    switch (format) {
      case 'html':
        return this.renderHTML(model);
      case 'pdf':
        return this.renderPDF(model);
      case 'xlsx':
        return this.renderXLSX(model);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private renderHTML(model: StructuredReportModel): RenderedReport {
    const html = this.generateHTML(model);

    return {
      id: uuidv4(),
      format: 'html',
      content: Buffer.from(html, 'utf8'),
      filename: `report_${model.planId}_${Date.now()}.html`,
      metadata: model.metadata
    };
  }

  private renderPDF(model: StructuredReportModel): RenderedReport {
    // TODO: Implement PDF generation using a library like puppeteer or pdfkit
    // For now, return HTML as PDF placeholder
    const html = this.generateHTML(model);
    const pdfBuffer = Buffer.from(html, 'utf8'); // Mock PDF generation

    return {
      id: uuidv4(),
      format: 'pdf',
      content: pdfBuffer,
      filename: `report_${model.planId}_${Date.now()}.pdf`,
      metadata: model.metadata
    };
  }

  private renderXLSX(model: StructuredReportModel): RenderedReport {
    // TODO: Implement Excel generation using a library like exceljs
    // For now, return CSV as XLSX placeholder
    const csv = this.generateCSV(model);
    const xlsxBuffer = Buffer.from(csv, 'utf8'); // Mock XLSX generation

    return {
      id: uuidv4(),
      format: 'xlsx',
      content: xlsxBuffer,
      filename: `report_${model.planId}_${Date.now()}.xlsx`,
      metadata: model.metadata
    };
  }

  private generateHTML(model: StructuredReportModel): string {
    const sections = model.sections.map(section => this.renderSectionHTML(section)).join('');

    return `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project Report - ${model.planId}</title>
    <style>
        ${this.getCSSStyles()}
    </style>
</head>
<body>
    <div class="report-container">
        <header class="report-header">
            <h1>Project Report</h1>
            <div class="report-meta">
                <p><strong>Plan ID:</strong> ${model.planId}</p>
                <p><strong>Generated:</strong> ${new Date(model.metadata.generatedAt).toLocaleString()}</p>
                <p><strong>Ledger TX:</strong> ${model.metadata.ledgerTx.substring(0, 16)}...</p>
            </div>
        </header>

        <main class="report-content">
            ${sections}
        </main>

        <footer class="report-footer">
            <p>Report generated by system on ${new Date().toLocaleString()}</p>
            <p>This is an immutable record with cryptographic verification.</p>
        </footer>
    </div>
</body>
</html>`;
  }

  private renderSectionHTML(section: ReportSection): string {
    switch (section.type) {
      case 'narrative':
        return this.renderNarrativeSection(section);
      case 'table':
        return this.renderTableSection(section);
      case 'summary':
        return this.renderSummarySection(section);
      case 'totals':
        return this.renderTotalsSection(section);
      default:
        return `<div class="section"><h2>${section.title}</h2><p>Unsupported section type</p></div>`;
    }
  }

  private renderNarrativeSection(section: ReportSection): string {
    let content = `<div class="section narrative-section">
        <h2>${section.title}</h2>`;

    if (section.content.text) {
      content += `<p class="narrative-text">${section.content.text}</p>`;
    }

    if (section.content.summary && Array.isArray(section.content.summary)) {
      content += '<ul class="narrative-list">';
      section.content.summary.forEach((item: string) => {
        content += `<li>${item}</li>`;
      });
      content += '</ul>';
    }

    if (section.content.detailedWork && Array.isArray(section.content.detailedWork)) {
      content += '<div class="detailed-work">';
      section.content.detailedWork.forEach((work: any) => {
        content += `
          <div class="work-item">
            <h4>${work.title}</h4>
            <p>${work.description}</p>
            <small>Status: ${work.status} | Time: ${(work.associatedTime / 60).toFixed(1)}h</small>
          </div>`;
      });
      content += '</div>';
    }

    content += '</div>';
    return content;
  }

  private renderTableSection(section: ReportSection): string {
    let content = `<div class="section table-section">
        <h2>${section.title}</h2>
        <table class="data-table">
            <thead><tr>`;

    if (section.content.headers) {
      section.content.headers.forEach((header: string) => {
        content += `<th>${header}</th>`;
      });
    }

    content += '</tr></thead><tbody>';

    if (section.content.rows) {
      section.content.rows.forEach((row: string[]) => {
        content += '<tr>';
        row.forEach((cell: string) => {
          content += `<td>${cell}</td>`;
        });
        content += '</tr>';
      });
    }

    content += '</tbody></table>';

    if (section.content.summary) {
      content += '<div class="table-summary">';
      Object.entries(section.content.summary).forEach(([key, value]) => {
        content += `<span class="summary-item"><strong>${key}:</strong> ${value}</span>`;
      });
      content += '</div>';
    }

    content += '</div>';
    return content;
  }

  private renderSummarySection(section: ReportSection): string {
    let content = `<div class="section summary-section">
        <h2>${section.title}</h2>
        <div class="summary-content">`;

    Object.entries(section.content).forEach(([key, value]) => {
      if (typeof value === 'object' && value !== null) {
        content += `<div class="summary-group">
            <h3>${key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</h3>`;
        Object.entries(value).forEach(([subKey, subValue]) => {
          content += `<p><strong>${subKey}:</strong> ${subValue}</p>`;
        });
        content += '</div>';
      } else {
        content += `<p><strong>${key}:</strong> ${value}</p>`;
      }
    });

    content += '</div></div>';
    return content;
  }

  private renderTotalsSection(section: ReportSection): string {
    let content = `<div class="section totals-section">
        <h2>${section.title}</h2>
        <div class="totals-content">`;

    Object.entries(section.content).forEach(([key, value]) => {
      content += `<div class="total-item ${key.toLowerCase()}">
          <span class="total-label">${key}</span>
          <span class="total-value">${value}</span>
      </div>`;
    });

    content += '</div></div>';
    return content;
  }

  private generateCSV(model: StructuredReportModel): string {
    let csv = 'Section,Type,Content\n';

    model.sections.forEach(section => {
      csv += `"${section.title}","${section.type}","${JSON.stringify(section.content).replace(/"/g, '""')}"\n`;
    });

    return csv;
  }

  private getCSSStyles(): string {
    return `
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f8f9fa;
            margin: 0;
            padding: 20px;
        }

        .report-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        }

        .report-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .report-header h1 {
            margin: 0 0 10px 0;
            font-size: 2.5em;
        }

        .report-meta {
            display: flex;
            justify-content: center;
            gap: 30px;
            font-size: 0.9em;
        }

        .report-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #667eea;
        }

        .section h2 {
            margin-top: 0;
            color: #667eea;
            border-bottom: 2px solid #e9ecef;
            padding-bottom: 10px;
        }

        .narrative-text {
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        .narrative-list {
            padding-left: 20px;
        }

        .narrative-list li {
            margin-bottom: 8px;
        }

        .detailed-work {
            margin-top: 20px;
        }

        .work-item {
            background: white;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .work-item h4 {
            margin: 0 0 8px 0;
            color: #495057;
        }

        .work-item small {
            color: #6c757d;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            margin-top: 15px;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        .data-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: #495057;
        }

        .data-table tr:hover {
            background: #f8f9fa;
        }

        .table-summary {
            margin-top: 15px;
            padding: 15px;
            background: #e9ecef;
            border-radius: 4px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .summary-item {
            display: inline-block;
        }

        .summary-content {
            display: grid;
            gap: 20px;
        }

        .summary-group {
            background: white;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #dee2e6;
        }

        .summary-group h3 {
            margin-top: 0;
            color: #495057;
        }

        .totals-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .totals-section h2 {
            color: white;
            border-bottom-color: rgba(255,255,255,0.3);
        }

        .totals-content {
            display: grid;
            gap: 15px;
        }

        .total-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
        }

        .total-label {
            font-weight: 600;
        }

        .total-value {
            font-size: 1.2em;
            font-weight: bold;
        }

        .report-footer {
            background: #f8f9fa;
            padding: 20px 30px;
            text-align: center;
            color: #6c757d;
            border-top: 1px solid #dee2e6;
        }

        @media print {
            body {
                background: white;
                padding: 0;
            }

            .report-container {
                box-shadow: none;
                border-radius: 0;
            }
        }
    `;
  }
}

// Export singleton instance
export const reportRenderer = new ReportRenderer();
